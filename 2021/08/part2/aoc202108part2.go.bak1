package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func parseLine(line string) (signals, outputs []string) {
	halfs := strings.Split(line, "|")
	s := strings.Fields(halfs[0])
	o := strings.Fields(halfs[1])

	signals = append(signals, s...)
	outputs = append(outputs, o...)

	return
}

func findPossibleMappings(input string) []int {
	strLen := len(input)
	switch strLen {
	case 2:
		// unique case
		return []int{1}
	case 3:
		// unique case
		return []int{7}
	case 4:
		// unique case
		return []int{4}
	case 5:
		return []int{2, 3, 5}
	case 6:
		return []int{0, 6, 9}
	case 7:
		// unique case
		return []int{8}
	default:
		// unreachable
		panic("unreachable")
	}
}

/* Original Segments;
 *
 *  aaaa
 * e    d
 * e    d
 *  bbbb
 * g    f
 * g    f
 *  cccc
 */

// segsInNumbers maps a segment to all the (displayed) numbers that contains
// it.
// Example: 'a': {0, 2, 3, 5, 6, 7, 8, 9},
// Segment 'a' is contained in the numbers 0, 2, 3, 5, 6, 7, 8, and 9.
var segsInNumbers = map[rune][]int{
	'a': {0, 2, 3, 5, 6, 7, 8, 9},
	'b': {2, 3, 4, 5, 6, 8, 9},
	'c': {0, 2, 3, 5, 6, 8, 9},
	'd': {0, 1, 2, 3, 4, 7, 8, 9},
	'e': {0, 4, 5, 6, 8, 9},
	'f': {0, 1, 3, 4, 5, 6, 7, 8, 9},
	'g': {0, 2, 6, 8},
}

var numberUsesSegs = map[int][]rune{
	0: {'a', 'c', 'd', 'e', 'f', 'g'},
	1: {'d', 'f'},
	2: {'a', 'b', 'c', 'd', 'g'},
	3: {'a', 'b', 'c', 'd', 'f'},
	4: {'b', 'd', 'e', 'f'},
	5: {'a', 'b', 'c', 'e', 'f'},
	6: {'a', 'b', 'c', 'e', 'f', 'g'},
	7: {'a', 'd', 'f'},
	8: {'a', 'b', 'c', 'd', 'e', 'f', 'g'},
	9: {'a', 'b', 'c', 'd', 'e', 'f'},
}

// segsNotInNumbers maps a segment to all the (displayed) numbers that do not
// contain it.
// Example: 'a': {1, 4},
// Segment 'a' is not contained in the numbers 1 and 4.
var segsNotInNumbers = map[rune][]int{
	'a': {1, 4},
	'b': {0, 1, 7},
	'c': {1, 4, 7},
	'd': {5, 6},
	'e': {1, 2, 3, 7},
	'f': {2},
	'g': {1, 3, 4, 5, 7, 9},
}

var numberNotUsesSegs = map[int][]rune{
	0: {'b'},
	1: {'a', 'b', 'c', 'e', 'g'},
	2: {'e', 'f'},
	3: {'e', 'g'},
	4: {'a', 'c', 'g'},
	5: {'d', 'g'},
	6: {'d'},
	7: {'b', 'c', 'e', 'g'},
	8: {},
	9: {'g'},
}

// map[int][]string
// 0: {"cagedb", "cdfgeb", "cefabd"},
// 1: {"ab"},
// 2: {"cdfbe", "fbcad", "gcdfa"},
// 3: {"cdfbe", "fbcad", "gcdfa"},
// 4: {"eafb"},
// 5: {"cdfbe", "fbcad", "gcdfa"},
// 6: {"cagedb", "cdfgeb", "cefabd"},
// 7: {"dab"},
// 8: {"acedgfb"},
// 9: {"cagedb", "cdfgeb", "cefabd"},
//
// 1. In 7 but not 1 -> maps to a
//
// ---
//
// Output:
// cdfeb fcadb cdfeb cdbaf
// 1. Sort alphabetically
// bcdef abcdf bcdef abcdf
// 2x bcdef, 2x abcdf -> length 5: 2,3,5
//
// ---
//
// ab:[1] acedgfb:[8] cagedb:[0 6 9] cdfbe:[2 3 5] cdfgeb:[0 6 9]
// cefabd:[0 6 9] dab:[7] eafb:[4] fbcad:[2 3 5] gcdfa:[2 3 5]
//
// 1. Replace each number with all the strings that the segment _could_ be
//    contained in.
// 2. Replace each number with all the strings that the segment _cannot_ be
//    contained in.
//
// [NOT IN] 'a': {"ab", "eafb"} // neither a, b, e, nor f can possibly be segment 'a'
// [IN] 'a': {"cagedb|cdfgeb|cefadb", "cdfbe|fbcad|gcdfa", ... }
//
// 3 Remove all of the chars from [NOT IN] from [IN]
//
// [IN] 'a': {"cgd|cdg|cd", "cd|cd|gcd", ... } // c, g, or d could possibly be segment 'a'

func findRunesNotIn(in, not string) []rune {
	for _, c := range not {
		in = strings.Replace(in, string(c), "", -1)
	}
	return []rune(in[:])
}

func main() {
	file, err := os.Open("test2.txt")

	if err != nil {
		panic(err)
	}

	defer file.Close()

	for scanner := bufio.NewScanner(file); scanner.Scan(); {
		line := scanner.Text()
		inputs, _ := parseLine(line)
		segmentsToPossibleNumbers := map[string][]int{}

		for i := 0; i < len(inputs); i++ {
			mappings := findPossibleMappings(inputs[i])
			segmentsToPossibleNumbers[inputs[i]] = mappings
		}

		fmt.Printf("-> The following segments could possibly display the"+
			" following numbers:\n%v\n\n", segmentsToPossibleNumbers)

		numbersToPossibleSignals := map[int][]string{}

		for k, v := range segmentsToPossibleNumbers {
			for _, i := range v {
				numbersToPossibleSignals[i] = append(numbersToPossibleSignals[i], k)
			}
		}

		fmt.Printf("-> The folowing numbers could possibly be displayed by the"+
			" following strings:\n%v\n\n", numbersToPossibleSignals)

		brokenToFixed := map[rune]rune{}

		// 1. The segment contained in seven but not in one MUST map to
		// original segment a.
		oneSeg := numbersToPossibleSignals[1][0]
		sevenSeg := numbersToPossibleSignals[7][0]
		segmentA := findRunesNotIn(sevenSeg, oneSeg)

		if len(segmentA) != 1 {
			panic("You suck!")
		}
		brokenToFixed['a'] = segmentA[0]

		fmt.Printf("fixed mapping:\n %v\n", brokenToFixed)
	}
}
