package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func parseLine(line string) (signals, outputs []string) {
	halfs := strings.Split(line, "|")
	s := strings.Fields(halfs[0])
	o := strings.Fields(halfs[1])

	signals = append(signals, s...)
	outputs = append(outputs, o...)

	return
}

/* Original Segments:
 *
 *  aaaa
 * e    d
 * e    d
 *  bbbb
 * g    f
 * g    f
 *  cccc
 */

var segsInNumbers = map[rune][]int{
	'a': {0, 2, 3, 5, 6, 7, 8, 9},
	'b': {2, 3, 4, 5, 6, 8, 9},
	'c': {0, 2, 3, 5, 6, 8, 9},
	'd': {0, 1, 2, 3, 4, 7, 8, 9},
	'e': {0, 4, 5, 6, 8, 9},
	'f': {0, 1, 3, 4, 5, 6, 7, 8, 9},
	'g': {0, 2, 6, 8},
}

var segsNotInNumbers = map[rune][]int{
	'a': {1, 4},
	'b': {0, 1, 7},
	'c': {1, 4, 7},
	'd': {5, 6},
	'e': {1, 2, 3, 7},
	'f': {2},
	'g': {1, 3, 4, 5, 7, 9},
}

func findPossibleMappings(input string) []int {
	strLen := len(input)
	switch strLen {
	case 2:
		// unique case
		return []int{1}
	case 3:
		// unique case
		return []int{7}
	case 4:
		// unique case
		return []int{4}
	case 5:
		return []int{2, 3, 5}
	case 6:
		return []int{0, 6, 9}
	case 7:
		// unique case
		return []int{8}
	default:
		// unreachable
		panic("unreachable")
	}
}

func removeChars(from, remove string) string {
	for _, r := range remove {
		c := string(r)
		from = strings.Replace(from, c, "", -1)
	}
	return from
}

func removeDuplicateChars(str string) string {
	fixedStr := ""
	for _, c := range str {
		res := strings.Contains(fixedStr, string(c))
		if !res {
			fixedStr += string(c)
		}
	}
	return fixedStr
}

func main() {
	file, err := os.Open("test2.txt")

	if err != nil {
		panic(err)
	}

	defer file.Close()

	for scanner := bufio.NewScanner(file); scanner.Scan(); {
		line := scanner.Text()
		inputs, _ := parseLine(line)
		segmentsToPossibleNumbers := map[string][]int{}

		for i := 0; i < len(inputs); i++ {
			mappings := findPossibleMappings(inputs[i])
			segmentsToPossibleNumbers[inputs[i]] = mappings
		}

		fmt.Printf("-> The following segments could possibly display the"+
			" following numbers:\n%v\n\n", segmentsToPossibleNumbers)

		numbersToPossibleSignals := map[int][]string{}

		for k, v := range segmentsToPossibleNumbers {
			for _, i := range v {
				numbersToPossibleSignals[i] = append(numbersToPossibleSignals[i], k)
			}
		}

		fmt.Printf("-> The folowing numbers could possibly be displayed by the"+
			" following strings:\n%v\n\n", numbersToPossibleSignals)

		brokenToFixed := map[rune]rune{}

		for _, v := range "abcdefg" {
			ins := ""
			notIns := ""

			nIn := segsInNumbers[v]
			nNotIn := segsNotInNumbers[v]

			// Replace those numbers with the possible strings
			for _, in := range nIn {
				signals := numbersToPossibleSignals[in]
				asSingleStr := strings.Join(signals, "")
				ins += asSingleStr
			}
			ins = removeDuplicateChars(ins)

			for _, notIn := range nNotIn {
				signals := numbersToPossibleSignals[notIn]
				asSingleStr := strings.Join(signals, "")
				notIns += asSingleStr
			}
			notIns = removeDuplicateChars(notIns)

			fmt.Println("ins:", ins)
			fmt.Println("notIns:", notIns)

			//ins = removeChars(ins, notIns)

			fmt.Printf("-> %c could be:%v\n\n", v, ins)
		}

		fmt.Printf("fixed mapping:\n %v\n", brokenToFixed)
	}
}
